/*
Shipping APIs

The Shipping APIs include a variety of operations that allow users to manage and track their shipping requests.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sp360shipping

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BatchAPIService BatchAPI service
type BatchAPIService service

type ApiBulkImportAPIRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	body *CreateBatchRequest
	xPBDeveloperPartnerID *string
}

//  This is the Request body to bulk import shipments.
func (r ApiBulkImportAPIRequest) Body(body CreateBatchRequest) ApiBulkImportAPIRequest {
	r.body = &body
	return r
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiBulkImportAPIRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiBulkImportAPIRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiBulkImportAPIRequest) Execute() (*ShipmentBatch, *http.Response, error) {
	return r.ApiService.BulkImportAPIExecute(r)
}

/*
BulkImportAPI Bulk Import Shipments

This operation imports the .CSV file, which includes all the required fields to create shipments in bulk. The payload contains information about the shipments you want to import, such as `carrier account`, `label layout`, `service`, and any `special services` required for the shipments. After batch is submitted, user needs to upload csv file of shipment transactions to the uploadURL returned in response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkImportAPIRequest
*/
func (a *BatchAPIService) BulkImportAPI(ctx context.Context) ApiBulkImportAPIRequest {
	return ApiBulkImportAPIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ShipmentBatch
func (a *BatchAPIService) BulkImportAPIExecute(r ApiBulkImportAPIRequest) (*ShipmentBatch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShipmentBatch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.BulkImportAPI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/importUrl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBulkShipmentsAPIRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	body *CreateBulkShipmentsAPIRequest
	xPBDeveloperPartnerID *string
}

// This is the Request body to create bulk shipments.
func (r ApiCreateBulkShipmentsAPIRequest) Body(body CreateBulkShipmentsAPIRequest) ApiCreateBulkShipmentsAPIRequest {
	r.body = &body
	return r
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiCreateBulkShipmentsAPIRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiCreateBulkShipmentsAPIRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiCreateBulkShipmentsAPIRequest) Execute() (*BulkShipmentResponse, *http.Response, error) {
	return r.ApiService.CreateBulkShipmentsAPIExecute(r)
}

/*
CreateBulkShipmentsAPI Create Bulk Shipments

This operation creates a batch of bulk (larger quantities) shipments for single or multiple recipients. The shipments can be addressed to a single or multiple recipients with different combination of carrier, service special services and parcel type. `carrierAccountId`, `parcelType`, `serviceId` and `specialServices` are used as default when user do not wish to provide at shipment level. If user choose to provide these at Shipment level then it overrides the values provided at root level. At shipment level either you can wish to provide all of `carrierAccountId`, `parcelType`, `serviceId` and `specialServices` or not provide all of them if wants to use default ones from root level. If user do not provide any one out of `carrierAccountId`, `parcelType` and `serviceId` at shipment level it would result in validation error

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBulkShipmentsAPIRequest
*/
func (a *BatchAPIService) CreateBulkShipmentsAPI(ctx context.Context) ApiCreateBulkShipmentsAPIRequest {
	return ApiCreateBulkShipmentsAPIRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BulkShipmentResponse
func (a *BatchAPIService) CreateBulkShipmentsAPIExecute(r ApiCreateBulkShipmentsAPIRequest) (*BulkShipmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BulkShipmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.CreateBulkShipmentsAPI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/bulkShipments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBatchStatusAPIRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	batchId string
	xPBDeveloperPartnerID *string
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetBatchStatusAPIRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetBatchStatusAPIRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiGetBatchStatusAPIRequest) Execute() (*GetStatusDetailedResponse, *http.Response, error) {
	return r.ApiService.GetBatchStatusAPIExecute(r)
}

/*
GetBatchStatusAPI Get Batch Status

This operation retrieves the status of an existing Batch identified by `{batchID}`. The response will provide information about its current status and whether the batch has been completed. Once job status is Completed, copy the url from response and paste in browser to download shipping label as PDF file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchId A unique identifier assigned to Batch which is automatically assigned by system while it is processed.
 @return ApiGetBatchStatusAPIRequest
*/
func (a *BatchAPIService) GetBatchStatusAPI(ctx context.Context, batchId string) ApiGetBatchStatusAPIRequest {
	return ApiGetBatchStatusAPIRequest{
		ApiService: a,
		ctx: ctx,
		batchId: batchId,
	}
}

// Execute executes the request
//  @return GetStatusDetailedResponse
func (a *BatchAPIService) GetBatchStatusAPIExecute(r ApiGetBatchStatusAPIRequest) (*GetStatusDetailedResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetStatusDetailedResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.GetBatchStatusAPI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/batch/{batchId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"batchId"+"}", url.PathEscape(parameterValueToString(r.batchId, "batchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []NotFoundErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShipmentDetailsForBatchAPIRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	batchId string
	xPBDeveloperPartnerID *string
	page *int32
	size *int32
	status *string
	step *string
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetShipmentDetailsForBatchAPIRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetShipmentDetailsForBatchAPIRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// The page number to return. The default is 1.
func (r ApiGetShipmentDetailsForBatchAPIRequest) Page(page int32) ApiGetShipmentDetailsForBatchAPIRequest {
	r.page = &page
	return r
}

// The number of records to return per page. The default is 20.
func (r ApiGetShipmentDetailsForBatchAPIRequest) Size(size int32) ApiGetShipmentDetailsForBatchAPIRequest {
	r.size = &size
	return r
}

// The status of the shipment. The default is all.
func (r ApiGetShipmentDetailsForBatchAPIRequest) Status(status string) ApiGetShipmentDetailsForBatchAPIRequest {
	r.status = &status
	return r
}

// The step of the batch processing.
func (r ApiGetShipmentDetailsForBatchAPIRequest) Step(step string) ApiGetShipmentDetailsForBatchAPIRequest {
	r.step = &step
	return r
}

func (r ApiGetShipmentDetailsForBatchAPIRequest) Execute() (*GetShipmentsForBatch, *http.Response, error) {
	return r.ApiService.GetShipmentDetailsForBatchAPIExecute(r)
}

/*
GetShipmentDetailsForBatchAPI Get Batch Shipment Details

This operation retrieves the shipment details which are SUCCESS or FAILED during batch processing of addressValidation, rating and labelGeneration. This also returns the detailed error for Failed shipments It takes following parameters `page`, `size`, `status` and `step`. Based on these parameters user can check shipment details for particular status at any processing step. If no values are provided default of page as 1, size as 20, status would show for all SUCCESS/FAILED and step would show all steps.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchId A unique identifier assigned to Batch which is automatically assigned by system while it is processed.
 @return ApiGetShipmentDetailsForBatchAPIRequest
*/
func (a *BatchAPIService) GetShipmentDetailsForBatchAPI(ctx context.Context, batchId string) ApiGetShipmentDetailsForBatchAPIRequest {
	return ApiGetShipmentDetailsForBatchAPIRequest{
		ApiService: a,
		ctx: ctx,
		batchId: batchId,
	}
}

// Execute executes the request
//  @return GetShipmentsForBatch
func (a *BatchAPIService) GetShipmentDetailsForBatchAPIExecute(r ApiGetShipmentDetailsForBatchAPIRequest) (*GetShipmentsForBatch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShipmentsForBatch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.GetShipmentDetailsForBatchAPI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/batch/{batchId}/shipments"
	localVarPath = strings.Replace(localVarPath, "{"+"batchId"+"}", url.PathEscape(parameterValueToString(r.batchId, "batchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []NotFoundErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSignatureImageERRRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	shipmentId string
	xPBDeveloperPartnerID *string
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetSignatureImageERRRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiGetSignatureImageERRRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiGetSignatureImageERRRequest) Execute() (*SignatureFileResponse, *http.Response, error) {
	return r.ApiService.GetSignatureImageERRExecute(r)
}

/*
GetSignatureImageERR Signature Image ERR

This operation retrieves and provide a downloadable link of signature image for specific ERR (Electronic Return Receipt) shipment. Signature image is the proof of delivered shipment. It's a digital copy of recipient's signature as proof of delivery.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId This indicates the shipment identifier.
 @return ApiGetSignatureImageERRRequest
*/
func (a *BatchAPIService) GetSignatureImageERR(ctx context.Context, shipmentId string) ApiGetSignatureImageERRRequest {
	return ApiGetSignatureImageERRRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return SignatureFileResponse
func (a *BatchAPIService) GetSignatureImageERRExecute(r ApiGetSignatureImageERRRequest) (*SignatureFileResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SignatureFileResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.GetSignatureImageERR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/err/shipments/{shipmentId}/signaturefile"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProcessBatchAPIRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	batchId string
	xPBDeveloperPartnerID *string
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiProcessBatchAPIRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiProcessBatchAPIRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiProcessBatchAPIRequest) Execute() (*ProcessShipmentResponse, *http.Response, error) {
	return r.ApiService.ProcessBatchAPIExecute(r)
}

/*
ProcessBatchAPI Process Batch

This operation processes (executes) the existing Batch. The payload for this endpoint is an empty JSON object {} because it does not require any additional data to be sent in the request body. The `batchId` parameter in the endpoint URL specifies which batch of shipments to process.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchId A unique identifier assigned to Batch which is automatically assigned by system while it is processed.
 @return ApiProcessBatchAPIRequest
*/
func (a *BatchAPIService) ProcessBatchAPI(ctx context.Context, batchId string) ApiProcessBatchAPIRequest {
	return ApiProcessBatchAPIRequest{
		ApiService: a,
		ctx: ctx,
		batchId: batchId,
	}
}

// Execute executes the request
//  @return ProcessShipmentResponse
func (a *BatchAPIService) ProcessBatchAPIExecute(r ApiProcessBatchAPIRequest) (*ProcessShipmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProcessShipmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.ProcessBatchAPI")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/batch/{batchId}/process"
	localVarPath = strings.Replace(localVarPath, "{"+"batchId"+"}", url.PathEscape(parameterValueToString(r.batchId, "batchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []NotFoundErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVoidShippingLabelRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	batchId string
	xPBDeveloperPartnerID *string
	voidBatchRequest *VoidBatchRequest
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiVoidShippingLabelRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiVoidShippingLabelRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

//  This is the Request body to Void batch shipping label.
func (r ApiVoidShippingLabelRequest) VoidBatchRequest(voidBatchRequest VoidBatchRequest) ApiVoidShippingLabelRequest {
	r.voidBatchRequest = &voidBatchRequest
	return r
}

func (r ApiVoidShippingLabelRequest) Execute() (*VoidBatchResponse, *http.Response, error) {
	return r.ApiService.VoidShippingLabelExecute(r)
}

/*
VoidShippingLabel Void Batch Shipping Labels

This operation cancel/void shipments created through batch. If user wants to void specific shipments of the batch, then has to provide shipmentIds in the shipmentIds[] array. And if wants to void/cancel all shipments of the batch then it do not need to provide shipmentIds in the array in request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchId A unique identifier assigned to Batch which is automatically assigned by system while it is processed.
 @return ApiVoidShippingLabelRequest
*/
func (a *BatchAPIService) VoidShippingLabel(ctx context.Context, batchId string) ApiVoidShippingLabelRequest {
	return ApiVoidShippingLabelRequest{
		ApiService: a,
		ctx: ctx,
		batchId: batchId,
	}
}

// Execute executes the request
//  @return VoidBatchResponse
func (a *BatchAPIService) VoidShippingLabelExecute(r ApiVoidShippingLabelRequest) (*VoidBatchResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VoidBatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.VoidShippingLabel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/batch/{batchId}/void"
	localVarPath = strings.Replace(localVarPath, "{"+"batchId"+"}", url.PathEscape(parameterValueToString(r.batchId, "batchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	// body params
	localVarPostBody = r.voidBatchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []NotFoundErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
