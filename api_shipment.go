/*
Shipping APIs

The Shipping APIs include a variety of operations that allow users to manage and track their shipping requests.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sp360shipping

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ShipmentAPIService ShipmentAPI service
type ShipmentAPIService service

type ApiCancelShipmentByIdRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	shipmentId string
	xPBDeveloperPartnerId *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiCancelShipmentByIdRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiCancelShipmentByIdRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

func (r ApiCancelShipmentByIdRequest) Execute() (*CancelShipment, *http.Response, error) {
	return r.ApiService.CancelShipmentByIdExecute(r)
}

/*
CancelShipmentById Cancel Shipment

The operation cancel/void shipment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId The shipmentId, a unique identifier assigned for the Shipment.
 @return ApiCancelShipmentByIdRequest
*/
func (a *ShipmentAPIService) CancelShipmentById(ctx context.Context, shipmentId string) ApiCancelShipmentByIdRequest {
	return ApiCancelShipmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return CancelShipment
func (a *ShipmentAPIService) CancelShipmentByIdExecute(r ApiCancelShipmentByIdRequest) (*CancelShipment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelShipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.CancelShipmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/{shipmentId}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []NotFoundErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelStampsERRRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	cancelStampsRequestERR *CancelStampsRequestERR
	xPBDeveloperPartnerID *string
}

func (r ApiCancelStampsERRRequest) CancelStampsRequestERR(cancelStampsRequestERR CancelStampsRequestERR) ApiCancelStampsERRRequest {
	r.cancelStampsRequestERR = &cancelStampsRequestERR
	return r
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiCancelStampsERRRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiCancelStampsERRRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

func (r ApiCancelStampsERRRequest) Execute() (*CancelStampsResponseERR, *http.Response, error) {
	return r.ApiService.CancelStampsERRExecute(r)
}

/*
CancelStampsERR Cancel Stamps ERR

This operation cancel/void stamps, generated for ERR (Electronic Return Receipt). User needs to provide `stampIds` to cancel those specific ERR stamps.  User will be able to download the refund form with details of generated postage. At a time, up to `1000` stamps can be requested for cancelation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelStampsERRRequest
*/
func (a *ShipmentAPIService) CancelStampsERR(ctx context.Context) ApiCancelStampsERRRequest {
	return ApiCancelStampsERRRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CancelStampsResponseERR
func (a *ShipmentAPIService) CancelStampsERRExecute(r ApiCancelStampsERRRequest) (*CancelStampsResponseERR, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CancelStampsResponseERR
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.CancelStampsERR")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/err/stamps/void"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.cancelStampsRequestERR == nil {
		return localVarReturnValue, nil, reportError("cancelStampsRequestERR is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/pdf", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	// body params
	localVarPostBody = r.cancelStampsRequestERR
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReturnLabelRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	shipmentId string
	returnLabel *ReturnLabel
	xPBDeveloperPartnerId *string
}

func (r ApiCreateReturnLabelRequest) ReturnLabel(returnLabel ReturnLabel) ApiCreateReturnLabelRequest {
	r.returnLabel = &returnLabel
	return r
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiCreateReturnLabelRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiCreateReturnLabelRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

func (r ApiCreateReturnLabelRequest) Execute() (*ReturnLabelResponse, *http.Response, error) {
	return r.ApiService.CreateReturnLabelExecute(r)
}

/*
CreateReturnLabel Create Return label shipment

The operation creates a return label based on a previous shipment. <br> The return label can be created in two ways:  <br> 1. User need not to provide any details of package, address, and service. The API would take all details from the shipmentId mentioned in the path parameter and would swap the address and create return label. However, for UPS `specialServices` object is required as carrier mandates to provide package description with PRL special service. <br> 2. User can customize the request by passing `fromAddress`, `toAddress`, `parcelType`, `serviceId` in the request itself. <br> Please Note that for UPS it is required to pass `specialServices` object with `PRL` service id and  input parameters with name as `RETURN_PKG_DESCRIPTION`. <br> For FedEx `specialServices` object is not required and PRL is added by default while creating return.  If user wishes to provide RMA number, it can be passed in `specialServices` object in the request body. <br> Please Note If user provides any information in this request, it overrides the information in onward shipment which was created <br> For example, if user provides toAddress in the request the return label will gets created with recipient as mentioned in toAddress and  if user provides fromAddress in the request, the return label will create with sender as mentioned in fromAddress

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId It specifies the shipmentId of onward shipment against which return label has to be created.
 @return ApiCreateReturnLabelRequest
*/
func (a *ShipmentAPIService) CreateReturnLabel(ctx context.Context, shipmentId string) ApiCreateReturnLabelRequest {
	return ApiCreateReturnLabelRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return ReturnLabelResponse
func (a *ShipmentAPIService) CreateReturnLabelExecute(r ApiCreateReturnLabelRequest) (*ReturnLabelResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReturnLabelResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.CreateReturnLabel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/{shipmentId}/return"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.returnLabel == nil {
		return localVarReturnValue, nil, reportError("returnLabel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	// body params
	localVarPostBody = r.returnLabel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateShipmentRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	createShipmentRequest *CreateShipmentRequest
	xPBDeveloperPartnerId *string
}

func (r ApiCreateShipmentRequest) CreateShipmentRequest(createShipmentRequest CreateShipmentRequest) ApiCreateShipmentRequest {
	r.createShipmentRequest = &createShipmentRequest
	return r
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiCreateShipmentRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiCreateShipmentRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

func (r ApiCreateShipmentRequest) Execute() (*CreateShipment200Response, *http.Response, error) {
	return r.ApiService.CreateShipmentExecute(r)
}

/*
CreateShipment Create Shipment

The operation creates a new Shipment or Shipment Label. This is for both Domestic and International. <br> For domestic, Create a shipment requires domestic addresses (within same country)- ToAddress and FromAddress,  and carrier service and special service. <br> While for International, Create a shipment requires international delivery, which is ToAddress must be the different country (and not the same country mentioned in From Address), selected services, special services, and customs information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateShipmentRequest
*/
func (a *ShipmentAPIService) CreateShipment(ctx context.Context) ApiCreateShipmentRequest {
	return ApiCreateShipmentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateShipment200Response
func (a *ShipmentAPIService) CreateShipmentExecute(r ApiCreateShipmentRequest) (*CreateShipment200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateShipment200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.CreateShipment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createShipmentRequest == nil {
		return localVarReturnValue, nil, reportError("createShipmentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	// body params
	localVarPostBody = r.createShipmentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllShipmentsRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerId *string
	startDate *string
	endDate *string
	page *string
	size *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetAllShipmentsRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiGetAllShipmentsRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// While searching shipments, user set a date range to get all created shipments. This indicatesthe start date of the set date range under shipment search criteria. The date format must be: YYYY-MM-DD.
func (r ApiGetAllShipmentsRequest) StartDate(startDate string) ApiGetAllShipmentsRequest {
	r.startDate = &startDate
	return r
}

// While searching shipments, user set a date range to get all created shipments. This indicatesthe end date of the set date range under shipment search criteria. The date format must be: YYYY-MM-DD.
func (r ApiGetAllShipmentsRequest) EndDate(endDate string) ApiGetAllShipmentsRequest {
	r.endDate = &endDate
	return r
}

// The page of the Shipments search result list.
func (r ApiGetAllShipmentsRequest) Page(page string) ApiGetAllShipmentsRequest {
	r.page = &page
	return r
}

// The size/count of the searched result list.
func (r ApiGetAllShipmentsRequest) Size(size string) ApiGetAllShipmentsRequest {
	r.size = &size
	return r
}

func (r ApiGetAllShipmentsRequest) Execute() (*GetAllShipments, *http.Response, error) {
	return r.ApiService.GetAllShipmentsExecute(r)
}

/*
GetAllShipments Get All Shipments

The operation fetches all created Shipments. If query parameters are not provided, it will default endDate as current date, page as 1 and size as 10.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllShipmentsRequest
*/
func (a *ShipmentAPIService) GetAllShipments(ctx context.Context) ApiGetAllShipmentsRequest {
	return ApiGetAllShipmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAllShipments
func (a *ShipmentAPIService) GetAllShipmentsExecute(r ApiGetAllShipmentsRequest) (*GetAllShipments, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAllShipments
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetAllShipments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCarrierAccountRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerId *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetCarrierAccountRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiGetCarrierAccountRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

func (r ApiGetCarrierAccountRequest) Execute() (*GetCarrierAccount200Response, *http.Response, error) {
	return r.ApiService.GetCarrierAccountExecute(r)
}

/*
GetCarrierAccount Get Carrier Accounts

The operation retrieves onboarded Carriers with their Carrier Account Ids which uniquely identify multiple accounts of same carrier.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCarrierAccountRequest
*/
func (a *ShipmentAPIService) GetCarrierAccount(ctx context.Context) ApiGetCarrierAccountRequest {
	return ApiGetCarrierAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetCarrierAccount200Response
func (a *ShipmentAPIService) GetCarrierAccountExecute(r ApiGetCarrierAccountRequest) (*GetCarrierAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetCarrierAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetCarrierAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/carrierAccounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCarriersRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerId *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetCarriersRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiGetCarriersRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

func (r ApiGetCarriersRequest) Execute() (*Carriers, *http.Response, error) {
	return r.ApiService.GetCarriersExecute(r)
}

/*
GetCarriers Get Carriers

The operation fetches all supported carriers. This service is used to get list of supported carriers and their properties.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCarriersRequest
*/
func (a *ShipmentAPIService) GetCarriers(ctx context.Context) ApiGetCarriersRequest {
	return ApiGetCarriersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Carriers
func (a *ShipmentAPIService) GetCarriersExecute(r ApiGetCarriersRequest) (*Carriers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Carriers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetCarriers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/carriers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCountriesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerId *string
	carrier *string
	originCountryCode *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetCountriesRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiGetCountriesRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// The carrierID, a unique identifier given to an individual carrier.
func (r ApiGetCountriesRequest) Carrier(carrier string) ApiGetCountriesRequest {
	r.carrier = &carrier
	return r
}

// The Source Country. The two-character ISO country code for the country where the Shipment originates.
func (r ApiGetCountriesRequest) OriginCountryCode(originCountryCode string) ApiGetCountriesRequest {
	r.originCountryCode = &originCountryCode
	return r
}

func (r ApiGetCountriesRequest) Execute() ([]CountriesInner, *http.Response, error) {
	return r.ApiService.GetCountriesExecute(r)
}

/*
GetCountries Get Countries

The operation fetches list of supported destination countries for a provided carrier and origin country. If query parameters are not provided, it will default to `USPS` as carrier and `US` as origin country.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCountriesRequest
*/
func (a *ShipmentAPIService) GetCountries(ctx context.Context) ApiGetCountriesRequest {
	return ApiGetCountriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []CountriesInner
func (a *ShipmentAPIService) GetCountriesExecute(r ApiGetCountriesRequest) ([]CountriesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []CountriesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetCountries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/countries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.carrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrier", r.carrier, "")
	}
	if r.originCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originCountryCode", r.originCountryCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetParcelTypesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerId *string
	carrier *string
	originCountryCode *string
	destinationCountryCode *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetParcelTypesRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiGetParcelTypesRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// The CarrierID, a unique identifier given to an individual carrier. It can be referred from the response of Get Carriers API
func (r ApiGetParcelTypesRequest) Carrier(carrier string) ApiGetParcelTypesRequest {
	r.carrier = &carrier
	return r
}

// The Source Country. The two-character ISO country code for the country where the Shipment originates.
func (r ApiGetParcelTypesRequest) OriginCountryCode(originCountryCode string) ApiGetParcelTypesRequest {
	r.originCountryCode = &originCountryCode
	return r
}

// The Destination Country for the Shipment. The two-character ISO country code for the country where the shipment is to be delivered.
func (r ApiGetParcelTypesRequest) DestinationCountryCode(destinationCountryCode string) ApiGetParcelTypesRequest {
	r.destinationCountryCode = &destinationCountryCode
	return r
}

func (r ApiGetParcelTypesRequest) Execute() ([]ParcelTypesInner, *http.Response, error) {
	return r.ApiService.GetParcelTypesExecute(r)
}

/*
GetParcelTypes Get Parcel Types

The operation fetches Parcel Types based on the provided carrier, origin county, and the destination country. If query parameters are not provided, this will default to `USPS` as carrier, `US` as both origin and destination country code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetParcelTypesRequest
*/
func (a *ShipmentAPIService) GetParcelTypes(ctx context.Context) ApiGetParcelTypesRequest {
	return ApiGetParcelTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ParcelTypesInner
func (a *ShipmentAPIService) GetParcelTypesExecute(r ApiGetParcelTypesRequest) ([]ParcelTypesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ParcelTypesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetParcelTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/parcelTypes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.carrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrier", r.carrier, "")
	}
	if r.originCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originCountryCode", r.originCountryCode, "")
	}
	if r.destinationCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationCountryCode", r.destinationCountryCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRatesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	getRatesRequest *GetRatesRequest
	xPBDeveloperPartnerId *string
	compactResponse *bool
}

func (r ApiGetRatesRequest) GetRatesRequest(getRatesRequest GetRatesRequest) ApiGetRatesRequest {
	r.getRatesRequest = &getRatesRequest
	return r
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetRatesRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiGetRatesRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// The header defines if the response required is detailed or compact. When value is set to true, it will only return rates object in response.
func (r ApiGetRatesRequest) CompactResponse(compactResponse bool) ApiGetRatesRequest {
	r.compactResponse = &compactResponse
	return r
}

func (r ApiGetRatesRequest) Execute() (*GetRates200Response, *http.Response, error) {
	return r.ApiService.GetRatesExecute(r)
}

/*
GetRates Rate Shop and Get Single Rate

This API contains 2 operations, rate shop and single rate. Rate shop will fetch rates for all carrier services based on the given addresses (From and To), weight, and dimension for given parcelType. If parcelType is not provided, it will default to `PKG`. Single rate will get rate for specific service and special service (if requested) based on the given addresses (From and To), weight, and dimension, parcelType and serviceId with or without specialServices. Single rate will be used mainly to a rate a shipment before creating shipment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRatesRequest
*/
func (a *ShipmentAPIService) GetRates(ctx context.Context) ApiGetRatesRequest {
	return ApiGetRatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetRates200Response
func (a *ShipmentAPIService) GetRatesExecute(r ApiGetRatesRequest) (*GetRates200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetRates200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetRates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/rates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.getRatesRequest == nil {
		return localVarReturnValue, nil, reportError("getRatesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.compactResponse != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "compactResponse", r.compactResponse, "")
	}
	// body params
	localVarPostBody = r.getRatesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServicesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerId *string
	carrier *string
	originCountryCode *string
	destinationCountryCode *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetServicesRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiGetServicesRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// The CarrierID, a unique identifier provided to an individual carrier. It can be referred from the response of Get Carriers API
func (r ApiGetServicesRequest) Carrier(carrier string) ApiGetServicesRequest {
	r.carrier = &carrier
	return r
}

// The Source Country. The two-character ISO country code for the country where the Shipment originates.
func (r ApiGetServicesRequest) OriginCountryCode(originCountryCode string) ApiGetServicesRequest {
	r.originCountryCode = &originCountryCode
	return r
}

// The Destination Country for the Shipment. The two-character ISO country code for the country where the shipment is to be delivered.
func (r ApiGetServicesRequest) DestinationCountryCode(destinationCountryCode string) ApiGetServicesRequest {
	r.destinationCountryCode = &destinationCountryCode
	return r
}

func (r ApiGetServicesRequest) Execute() ([]ServicesInner, *http.Response, error) {
	return r.ApiService.GetServicesExecute(r)
}

/*
GetServices Get Services

The operation fetches a list of supported services for a carrier with respect to specific origin and destination country. If query parameters are not provided, this will default to `USPS` as carrier, `US` as both origin and destination country code.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetServicesRequest
*/
func (a *ShipmentAPIService) GetServices(ctx context.Context) ApiGetServicesRequest {
	return ApiGetServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ServicesInner
func (a *ShipmentAPIService) GetServicesExecute(r ApiGetServicesRequest) ([]ServicesInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ServicesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/services"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.carrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrier", r.carrier, "")
	}
	if r.originCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originCountryCode", r.originCountryCode, "")
	}
	if r.destinationCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationCountryCode", r.destinationCountryCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpecialServicesRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	xPBDeveloperPartnerId *string
	service *string
	parcel *string
	carrier *string
	originCountryCode *string
	destinationCountryCode *string
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiGetSpecialServicesRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiGetSpecialServicesRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// The serviceId. It can be referred from response of &#x60;Get Services&#x60; API
func (r ApiGetSpecialServicesRequest) Service(service string) ApiGetSpecialServicesRequest {
	r.service = &service
	return r
}

// The parcel Id, a unique identifier named to individual package. It can be referred from response of &#x60;Get Parcel Types&#x60; API
func (r ApiGetSpecialServicesRequest) Parcel(parcel string) ApiGetSpecialServicesRequest {
	r.parcel = &parcel
	return r
}

// The CarrierID, a unique identifier given to an individual carrier. It can be referred from response of &#x60;Get Carriers&#x60; API
func (r ApiGetSpecialServicesRequest) Carrier(carrier string) ApiGetSpecialServicesRequest {
	r.carrier = &carrier
	return r
}

// The Source Country. The two-character ISO country code for the country where the Shipment originates.
func (r ApiGetSpecialServicesRequest) OriginCountryCode(originCountryCode string) ApiGetSpecialServicesRequest {
	r.originCountryCode = &originCountryCode
	return r
}

// The Destination Country for the Shipment. The two-character ISO country code for the country where the shipment is to be delivered.
func (r ApiGetSpecialServicesRequest) DestinationCountryCode(destinationCountryCode string) ApiGetSpecialServicesRequest {
	r.destinationCountryCode = &destinationCountryCode
	return r
}

func (r ApiGetSpecialServicesRequest) Execute() (*SpecialServices, *http.Response, error) {
	return r.ApiService.GetSpecialServicesExecute(r)
}

/*
GetSpecialServices Get Special Services

The operation fetches Special Services for a given carrier, service, origin country, and the destination country. If query parameters are not provided, it will default to `USPS` as carrier, `US` as both origin, and destination country and will show for all service and parcel types

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSpecialServicesRequest
*/
func (a *ShipmentAPIService) GetSpecialServices(ctx context.Context) ApiGetSpecialServicesRequest {
	return ApiGetSpecialServicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SpecialServices
func (a *ShipmentAPIService) GetSpecialServicesExecute(r ApiGetSpecialServicesRequest) (*SpecialServices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SpecialServices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.GetSpecialServices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/specialServices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.service != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "service", r.service, "")
	}
	if r.parcel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parcel", r.parcel, "")
	}
	if r.carrier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "carrier", r.carrier, "")
	}
	if r.originCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "originCountryCode", r.originCountryCode, "")
	}
	if r.destinationCountryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destinationCountryCode", r.destinationCountryCode, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReprintShipmentByIdRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	shipmentId string
	xPBDeveloperPartnerId *string
	compactResponse *bool
}

// This is the Developer Partner ID. When the developer is the only partner, this field is not required.
func (r ApiReprintShipmentByIdRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiReprintShipmentByIdRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// The header defines if the response required is detailed or compact. When value is set to true, it will only return label layout details and parcel tracking number object in response.
func (r ApiReprintShipmentByIdRequest) CompactResponse(compactResponse bool) ApiReprintShipmentByIdRequest {
	r.compactResponse = &compactResponse
	return r
}

func (r ApiReprintShipmentByIdRequest) Execute() (*ReprintShipment, *http.Response, error) {
	return r.ApiService.ReprintShipmentByIdExecute(r)
}

/*
ReprintShipmentById Reprint Shipment

The operation reprints Shipment by the shipmentId. It retrieves an existing shipping label to reprint. The API sends the shipmentId returned by the original Created Shipment request. Use this only if the shipping label in the Create Shipment response is missing or lost.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId The shipmentId, a unique identifier assigned to the Shipment.
 @return ApiReprintShipmentByIdRequest
*/
func (a *ShipmentAPIService) ReprintShipmentById(ctx context.Context, shipmentId string) ApiReprintShipmentByIdRequest {
	return ApiReprintShipmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return ReprintShipment
func (a *ShipmentAPIService) ReprintShipmentByIdExecute(r ApiReprintShipmentByIdRequest) (*ReprintShipment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReprintShipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.ReprintShipmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/{shipmentId}/reprint"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.compactResponse != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "compactResponse", r.compactResponse, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []NotFoundErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShipmentByIdRequest struct {
	ctx context.Context
	ApiService *ShipmentAPIService
	shipmentId string
	xPBDeveloperPartnerId *string
}

// This is the Developer Partner ID assigned by PB, which is used in API for communication with strategic business partners. When the developer is the only business partner, this field is not required.
func (r ApiShipmentByIdRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiShipmentByIdRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

func (r ApiShipmentByIdRequest) Execute() (*GetSingleShipment, *http.Response, error) {
	return r.ApiService.ShipmentByIdExecute(r)
}

/*
ShipmentById Get Shipment by Id

The operation retrieves shipment details using shipmentId.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipmentId The shipmentId, a unique identifier for an individual Shipment.
 @return ApiShipmentByIdRequest
*/
func (a *ShipmentAPIService) ShipmentById(ctx context.Context, shipmentId string) ApiShipmentByIdRequest {
	return ApiShipmentByIdRequest{
		ApiService: a,
		ctx: ctx,
		shipmentId: shipmentId,
	}
}

// Execute executes the request
//  @return GetSingleShipment
func (a *ShipmentAPIService) ShipmentByIdExecute(r ApiShipmentByIdRequest) (*GetSingleShipment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSingleShipment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ShipmentAPIService.ShipmentById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/shipments/{shipmentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"shipmentId"+"}", url.PathEscape(parameterValueToString(r.shipmentId, "shipmentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []NotFoundErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
