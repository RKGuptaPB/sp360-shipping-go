/*
Shipping APIs

The Shipping APIs include a variety of operations that allow users to manage and track their shipping requests.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sp360shipping

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PrintAPIService PrintAPI service
type PrintAPIService service

type ApiDeletePrinterMappingRequest struct {
	ctx context.Context
	ApiService *PrintAPIService
	alias *string
	xPBDeveloperPartnerId *string
	xPBLocationId *string
	xPBTransactionId *string
}

// Refers to a printer connected (directly or via network) to a computer.
func (r ApiDeletePrinterMappingRequest) Alias(alias string) ApiDeletePrinterMappingRequest {
	r.alias = &alias
	return r
}

// The Developer Partner ID assigned by PB, which is used in API for communication with strategic business partners. When the developer is the only business partner, this field is not required.
func (r ApiDeletePrinterMappingRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiDeletePrinterMappingRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// This is the Location ID assigned as per the Developer Partner&#39;s location.
func (r ApiDeletePrinterMappingRequest) XPBLocationId(xPBLocationId string) ApiDeletePrinterMappingRequest {
	r.xPBLocationId = &xPBLocationId
	return r
}

// A unique transaction Id provided by the partner which is used to enable debugging and linking between the client&#39;s transaction and the system.
func (r ApiDeletePrinterMappingRequest) XPBTransactionId(xPBTransactionId string) ApiDeletePrinterMappingRequest {
	r.xPBTransactionId = &xPBTransactionId
	return r
}

func (r ApiDeletePrinterMappingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletePrinterMappingExecute(r)
}

/*
DeletePrinterMapping Delete Printer mapping

delete printer mapping document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeletePrinterMappingRequest
*/
func (a *PrintAPIService) DeletePrinterMapping(ctx context.Context) ApiDeletePrinterMappingRequest {
	return ApiDeletePrinterMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PrintAPIService) DeletePrinterMappingExecute(r ApiDeletePrinterMappingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintAPIService.DeletePrinterMapping")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/printer/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alias == nil {
		return nil, reportError("alias is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "alias", r.alias, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.xPBLocationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-LocationId", r.xPBLocationId, "")
	}
	if r.xPBTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-TransactionId", r.xPBTransactionId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetPrinterMappingRequest struct {
	ctx context.Context
	ApiService *PrintAPIService
	alias *string
	xPBDeveloperPartnerId *string
	xPBLocationId *string
	xPBTransactionId *string
}

// Refers to a printer connected (directly or via network) to a computer.
func (r ApiGetPrinterMappingRequest) Alias(alias string) ApiGetPrinterMappingRequest {
	r.alias = &alias
	return r
}

// The Developer Partner ID assigned by PB, which is used in API for communication with strategic business partners. When the developer is the only business partner, this field is not required.
func (r ApiGetPrinterMappingRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiGetPrinterMappingRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// This is the Location ID assigned as per the Developer Partner&#39;s location.
func (r ApiGetPrinterMappingRequest) XPBLocationId(xPBLocationId string) ApiGetPrinterMappingRequest {
	r.xPBLocationId = &xPBLocationId
	return r
}

// A unique transaction Id provided by the partner which is used to enable debugging and linking between the client&#39;s transaction and the system.
func (r ApiGetPrinterMappingRequest) XPBTransactionId(xPBTransactionId string) ApiGetPrinterMappingRequest {
	r.xPBTransactionId = &xPBTransactionId
	return r
}

func (r ApiGetPrinterMappingRequest) Execute() (*PrinterMappingGetResponse, *http.Response, error) {
	return r.ApiService.GetPrinterMappingExecute(r)
}

/*
GetPrinterMapping Get Printer mapping

Get printer mapping document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPrinterMappingRequest
*/
func (a *PrintAPIService) GetPrinterMapping(ctx context.Context) ApiGetPrinterMappingRequest {
	return ApiGetPrinterMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PrinterMappingGetResponse
func (a *PrintAPIService) GetPrinterMappingExecute(r ApiGetPrinterMappingRequest) (*PrinterMappingGetResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrinterMappingGetResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintAPIService.GetPrinterMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/printer/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.alias == nil {
		return localVarReturnValue, nil, reportError("alias is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "alias", r.alias, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.xPBLocationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-LocationId", r.xPBLocationId, "")
	}
	if r.xPBTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-TransactionId", r.xPBTransactionId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJobStatusRequest struct {
	ctx context.Context
	ApiService *PrintAPIService
	jobId string
	xPBDeveloperPartnerId *string
	xPBLocationId *string
	xPBTransactionId *string
}

// The Developer Partner ID assigned by PB, which is used in API for communication with strategic business partners. When the developer is the only business partner, this field is not required.
func (r ApiJobStatusRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiJobStatusRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// This is the Location ID assigned as per the Developer Partner&#39;s location.
func (r ApiJobStatusRequest) XPBLocationId(xPBLocationId string) ApiJobStatusRequest {
	r.xPBLocationId = &xPBLocationId
	return r
}

// A unique transaction Id provided by the partner which is used to enable debugging and linking between the client&#39;s transaction and the system.
func (r ApiJobStatusRequest) XPBTransactionId(xPBTransactionId string) ApiJobStatusRequest {
	r.xPBTransactionId = &xPBTransactionId
	return r
}

func (r ApiJobStatusRequest) Execute() (*JobStatus, *http.Response, error) {
	return r.ApiService.JobStatusExecute(r)
}

/*
JobStatus Job status

job status

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId The jobId, a unique identifier assigned for the job.
 @return ApiJobStatusRequest
*/
func (a *PrintAPIService) JobStatus(ctx context.Context, jobId string) ApiJobStatusRequest {
	return ApiJobStatusRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return JobStatus
func (a *PrintAPIService) JobStatusExecute(r ApiJobStatusRequest) (*JobStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JobStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintAPIService.JobStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.xPBLocationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-LocationId", r.xPBLocationId, "")
	}
	if r.xPBTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-TransactionId", r.xPBTransactionId, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrintDocumentRequest struct {
	ctx context.Context
	ApiService *PrintAPIService
	printDocumentRequest *PrintDocumentRequest
	xPBDeveloperPartnerId *string
	xPBLocationId *string
	xPBTransactionId *string
}

func (r ApiPrintDocumentRequest) PrintDocumentRequest(printDocumentRequest PrintDocumentRequest) ApiPrintDocumentRequest {
	r.printDocumentRequest = &printDocumentRequest
	return r
}

// The Developer Partner ID assigned by PB, which is used in API for communication with strategic business partners. When the developer is the only business partner, this field is not required.
func (r ApiPrintDocumentRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiPrintDocumentRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// This is the Location ID assigned as per the Developer Partner&#39;s location.
func (r ApiPrintDocumentRequest) XPBLocationId(xPBLocationId string) ApiPrintDocumentRequest {
	r.xPBLocationId = &xPBLocationId
	return r
}

// A unique Transaction ID provided by the partner, which is used to enable debugging and linking between the client&#39;s transaction and the system.
func (r ApiPrintDocumentRequest) XPBTransactionId(xPBTransactionId string) ApiPrintDocumentRequest {
	r.xPBTransactionId = &xPBTransactionId
	return r
}

func (r ApiPrintDocumentRequest) Execute() (*PrintDocumentResponse, *http.Response, error) {
	return r.ApiService.PrintDocumentExecute(r)
}

/*
PrintDocument Print Document

It contains information about a label or document, e.g. a shipping label, a customs form, manifest report etc., that pertains to a shipment or manifest.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrintDocumentRequest
*/
func (a *PrintAPIService) PrintDocument(ctx context.Context) ApiPrintDocumentRequest {
	return ApiPrintDocumentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PrintDocumentResponse
func (a *PrintAPIService) PrintDocumentExecute(r ApiPrintDocumentRequest) (*PrintDocumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrintDocumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintAPIService.PrintDocument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/document/print"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.printDocumentRequest == nil {
		return localVarReturnValue, nil, reportError("printDocumentRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.xPBLocationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-LocationId", r.xPBLocationId, "")
	}
	if r.xPBTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-TransactionId", r.xPBTransactionId, "")
	}
	// body params
	localVarPostBody = r.printDocumentRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPrinterMappingRequest struct {
	ctx context.Context
	ApiService *PrintAPIService
	printerMappingRequest *PrinterMappingRequest
	xPBDeveloperPartnerId *string
	xPBLocationId *string
	xPBTransactionId *string
}

func (r ApiPrinterMappingRequest) PrinterMappingRequest(printerMappingRequest PrinterMappingRequest) ApiPrinterMappingRequest {
	r.printerMappingRequest = &printerMappingRequest
	return r
}

// The Developer Partner ID assigned by PB, which is used in API for communication with strategic business partners. When the developer is the only business partner, this field is not required.
func (r ApiPrinterMappingRequest) XPBDeveloperPartnerId(xPBDeveloperPartnerId string) ApiPrinterMappingRequest {
	r.xPBDeveloperPartnerId = &xPBDeveloperPartnerId
	return r
}

// This is the Location ID assigned as per the Developer Partner&#39;s location.
func (r ApiPrinterMappingRequest) XPBLocationId(xPBLocationId string) ApiPrinterMappingRequest {
	r.xPBLocationId = &xPBLocationId
	return r
}

// A unique transaction Id provided by the partner which is used to enable debugging and linking between the client&#39;s transaction and the system.
func (r ApiPrinterMappingRequest) XPBTransactionId(xPBTransactionId string) ApiPrinterMappingRequest {
	r.xPBTransactionId = &xPBTransactionId
	return r
}

func (r ApiPrinterMappingRequest) Execute() (*PrinterMappingResponse, *http.Response, error) {
	return r.ApiService.PrinterMappingExecute(r)
}

/*
PrinterMapping Printer mapping

printer mapping document

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPrinterMappingRequest
*/
func (a *PrintAPIService) PrinterMapping(ctx context.Context) ApiPrinterMappingRequest {
	return ApiPrinterMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PrinterMappingResponse
func (a *PrintAPIService) PrinterMappingExecute(r ApiPrinterMappingRequest) (*PrinterMappingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PrinterMappingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PrintAPIService.PrinterMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/printer/mapping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.printerMappingRequest == nil {
		return localVarReturnValue, nil, reportError("printerMappingRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-Id", r.xPBDeveloperPartnerId, "")
	}
	if r.xPBLocationId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-LocationId", r.xPBLocationId, "")
	}
	if r.xPBTransactionId != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-TransactionId", r.xPBTransactionId, "")
	}
	// body params
	localVarPostBody = r.printerMappingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
