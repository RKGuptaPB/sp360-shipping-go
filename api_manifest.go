/*
Shipping APIs

The Shipping APIs include a variety of operations that allow users to manage and track their shipping requests.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package sp360shipping

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ManifestAPIService ManifestAPI service
type ManifestAPIService service

type ApiCreateManifestRequest struct {
	ctx context.Context
	ApiService *ManifestAPIService
	xPBDeveloperPartnerID *string
	compactResponse *bool
	createManifestRequest *CreateManifestRequest
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiCreateManifestRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiCreateManifestRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// This header defines if the response required is detailed or compact. When value is set to true, it will only return manifest details in response. 
func (r ApiCreateManifestRequest) CompactResponse(compactResponse bool) ApiCreateManifestRequest {
	r.compactResponse = &compactResponse
	return r
}

func (r ApiCreateManifestRequest) CreateManifestRequest(createManifestRequest CreateManifestRequest) ApiCreateManifestRequest {
	r.createManifestRequest = &createManifestRequest
	return r
}

func (r ApiCreateManifestRequest) Execute() (*CreateManifest200Response, *http.Response, error) {
	return r.ApiService.CreateManifestExecute(r)
}

/*
CreateManifest Create Manifest

This operation creates an end-of-day manifest (a compilation of information about all shipments) that combines all shipments of the day into a single form or electronic record, depending on the carrier. For different carriers, the Manifest process varies, e.g., USPS use SCAN Form while FedEx has Manifest Form.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateManifestRequest
*/
func (a *ManifestAPIService) CreateManifest(ctx context.Context) ApiCreateManifestRequest {
	return ApiCreateManifestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateManifest200Response
func (a *ManifestAPIService) CreateManifestExecute(r ApiCreateManifestRequest) (*CreateManifest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateManifest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManifestAPIService.CreateManifest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/manifests"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	if r.compactResponse != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "compactResponse", r.compactResponse, "")
	}
	// body params
	localVarPostBody = r.createManifestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReprintManifestRequest struct {
	ctx context.Context
	ApiService *ManifestAPIService
	xPBDeveloperPartnerID *string
	compactResponse *bool
	reprintManifestRequest *ReprintManifestRequest
}

// This is the Develover Partner ID. When the developer is the only partner, this field is not required.
func (r ApiReprintManifestRequest) XPBDeveloperPartnerID(xPBDeveloperPartnerID string) ApiReprintManifestRequest {
	r.xPBDeveloperPartnerID = &xPBDeveloperPartnerID
	return r
}

// This header defines if the response required is detailed or compact. When value is set to true, it will only return manifest details in response.
func (r ApiReprintManifestRequest) CompactResponse(compactResponse bool) ApiReprintManifestRequest {
	r.compactResponse = &compactResponse
	return r
}

func (r ApiReprintManifestRequest) ReprintManifestRequest(reprintManifestRequest ReprintManifestRequest) ApiReprintManifestRequest {
	r.reprintManifestRequest = &reprintManifestRequest
	return r
}

func (r ApiReprintManifestRequest) Execute() (*CreateManifest200Response, *http.Response, error) {
	return r.ApiService.ReprintManifestExecute(r)
}

/*
ReprintManifest Reprint manifest

This operation reprints a manifest for which the initial created manifest request was successful.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReprintManifestRequest
*/
func (a *ManifestAPIService) ReprintManifest(ctx context.Context) ApiReprintManifestRequest {
	return ApiReprintManifestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateManifest200Response
func (a *ManifestAPIService) ReprintManifestExecute(r ApiReprintManifestRequest) (*CreateManifest200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateManifest200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ManifestAPIService.ReprintManifest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/manifests/reprint"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPBDeveloperPartnerID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-PB-Developer-Partner-ID", r.xPBDeveloperPartnerID, "")
	}
	if r.compactResponse != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "compactResponse", r.compactResponse, "")
	}
	// body params
	localVarPostBody = r.reprintManifestRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []ErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []NotFoundErrorsInner
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
